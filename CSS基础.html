<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSS基础</title>
    <style>
        @font-face {
            font-family: 'icomoon';
            src:  url('fonts/icomoon.eot?mpzgix');
            src:  url('fonts/icomoon.eot?mpzgix#iefix') format('embedded-opentype'),
                url('fonts/icomoon.ttf?mpzgix') format('truetype'),
                url('fonts/icomoon.woff?mpzgix') format('woff'),
                url('fonts/icomoon.svg?mpzgix#icomoon') format('svg');
            font-weight: normal;
            font-style: normal;
            font-display: block;
        }

        /* CSS语法说明
        CSS规则主要有两部分构成：选择器以及一条或多条声明。
            （1）选择器：即指向您需要设置样式的 HTML 元素。
            （2）声明块包含一条或多条用“;”分隔的声明。
            （3）每条声明都以键值对的形式出现，即都包含一个 CSS 属性名称和一个值，以“：”分隔。
            （4）多条 CSS 声明用分号分隔，声明块用花括号括起来。
        */
        p {
            color: red;
            text-indent: 2em;
            line-height: 26px;
        }

        /* CSS代码风格：以下代码风格不是强制规范，而是实际开发中的书写方式。
            1、样式格式书写
                （1）紧凑型（不提倡）
                    h3 {color: blue;font-size: 20px;}
                （2）展开型（提倡，看起来清晰直观）
                    h3 {
                        color: blue;
                        font-size: 20px;
                    }
            2、样式大小写风格
                强烈推荐样式选择器、属性名和属性值关键词全部使用小写字母，特殊情况除外
            3、样式空格风格
                （1）属性值前面，冒号后面，保留一个空格；
                （2）选择器后面，大括号之前保留一个空格。
        */

        /* CSS属性书写顺序
            建议遵循以下顺序：
            1、布局定位属性：display/position/float/clear/visibility/overflow（建议display第一个写，毕竟关系到模式）
            2、自身属性：width/height/margin/padding/border/background
            3、文本属性：color/font/text-decoration/text-align/vertical-align/white-space/break-word
            4、其他属性(CSS3)：content/cursor/border-radius/box-shadow/text-shadow/background:linear-gradient...
        */

        /* 页面布局整体思路：
            第一步，确定页面核心版心（视觉核心区），测量可得知；
            第二步，分析页面中的行模块，以及每个行模块中的列模块。（页面布局第一准则）
            第三步，一行中的列模块经常浮动布局，先确定每个列的大小，之后确定列的位置。（页面布局第二准则）
            第四步，制作HTML结构，遵循先有结构，再写样式的原则，结构永远最重要
        */

        /* 常见布局技巧
            一、margin负值的运用
                1、让每个浮动盒子margin往左侧移动一个负border的长度，正好压住相邻边框盒子，解决相邻元素边框贴合变粗的问题。但是
                    ，每个浮动盒子左负外边距存在两个问题：
                        （问题1）每两个相邻浮动盒子，其中一个右边框会被压住（没有z-index或z-index相同时，文档流中靠后的元素会盖在靠
                        前的元素之上），所以鼠标:hover无法正常显示边框。
                            (解决办法）鼠标经过某个盒子的时候，提高当前盒子的层级即可。如果没有定位，加上相对定位（定位元素通常会比常规文档流中的盒子层级更高；如果已经有定位，加z-index
                        （问题2）最左侧的盒子边框会移动到容器之外，此时消除浮动的影响不能使用overflow: hidden;
                            (解决办法) 用其他清除浮动的办法即可

                    【拓展】
                    “正好压住相邻边框盒子”中的“压”的用词非常准确，如果想让鼠标经过浮动元素的时候边框变色，除了最后一个边框正常
                    显示，前面的盒子的有边框无法正常变色，因为被压住了。

            二、文字围绕浮动元素
                利用浮动产生的目的：文字环绕浮动元素，即浮动元素不会覆盖标准流的文字

            三、行内块的巧妙运用
                利用行内块元素之间存在间隙

            四、CSS三角强化
                见结构中的“CSS三角实现梯形价格对比”案例
        */
        .layout {
            border: 10px solid rgba(0,0,0,);
            text-align: center;
        }
        .layout ul{
            /* overflow: hidden; */
            width: 512px;
            margin: 0 auto;
        }
        .layout .clearfix:before, .clearfix:after {
            content: "";
            display: table;
        }
        .layout .clearfix:after {
            clear: both;
        }
        .layout .clearfix {  
            *zoom: 1;
        }  
        .layout li {
            /* 浮动元素可以设置相对定位，通常先按照浮动的规则进行布局，然后相对定位再基于浮动后的位置进行偏移 */
            /* 浮动元素也可以设置绝对定位和固定定位，但定位起主导作用，浮动一般会失效 */
            position: relative;
            float: left;
            width: 100px;
            height: 150px;
            margin-left: -2px;
            background: #e5e5e5;
            border: 2px solid pink;
        }
        /*  如果盒子没有定位，则鼠标经过添加相对定位
        .layout li:hover {
            position: relative;
            border: 2px solid blue;
        }
        */
        .layout li:hover {
            z-index: 1;
            border: 2px solid blue;
        }

        .text-flow {
            overflow: hidden;
            width: 500px;
            height: 200px;
            margin: 10px auto;
            padding: 10px;
            border: 1px solid rgba(0,0,0,.4);
        }
        .text-flow div {
            float: left;
            width: 200px;
            height: 200px;
            background: green;
        }
        
        .miaosha {
            width: 500px;
            height: 50px;
            line-height: 50px;
            margin: 0 auto;
            border: 2px solid red;
            color: white;
            font-size: 30px;
            font-weight: 700;
            text-align: center;
        }
        .miaosha .trapezium {
            position: relative;
            float: left;
            width: 250px;
            height: 100%;
            background-color: red;
        }
        .trapezium + span {
            color: rgba(0,0,0,.4);
            font-size: 24px;
            font-weight: 300;
            text-decoration: line-through;
        }
        .trapezium i{
            position: absolute;
            top: 0;
            right: 0;
            width: 0;
            height: 0;
            /* 
                border-top: 0px solid yellow;
                border-bottom: 200px solid pink;
                border-left: 100px solid transparent;
                border-right: 0px solid firebrick;
            */
            border-color: yellow firebrick white transparent;
            border-width: 0 0 50px 25px;
            border-style: solid;
        }

        /* CSS选择器
        CSS选择器的分类:
        1、基础选择器（根据标签名称、id、类来选取元素） 
            (1)标签选择器：根据标签的名称把所有的同类标签全部选出来。如：
                标签名称 {
                    属性: 属性值;
                }
                【标签选择器语法说明】
                1）使用场景：较多
            (2)类选择器：如果想要差异化选择不同的标签，单独选一个或某几个标签，可以选择类选择器。如：
                .类名 {
                    属性: 属性值；
                }

                【类选择器语法说明】
                1）结构需要class属性来调用class类；
                    【补充说明】一个标签可以指定多个类名，多类名中间用空格分开
                2）可以理解为给这个标签取一个名字；
                3）长名称或词组可以使用横线来为选择器命名;
                4）不要使用纯数字、中文来命名，尽量用英文来表示；
                5）命名要有意义，尽量让别人一眼就看到这个类名的目的；
                6）基本命名规范，见“Web前端开发规范手册”；
                7）使用场景：非常多。
            (3)id选择器：为特定id的HTML元素指定特定的样式。
                【id选择器语法说明】
                1）HTML元素以id属性设置id选择器，CSS中以“#”来定义；
                2）元素的 id 在页面中是唯一的，因此 id 选择器用于选择一个唯一的元素
                3)使用场景：一般和javascript搭配使用。
            (4)通配符选择器：在CSS中，通配符选择器通常使用“*”定义，它表示选取页面中所有标签。
                【通配符选择器语法说明】
                1）不需要调用，自动就给所有标签使用样式；
                2）使用场景：特殊情况才使用，后面会讲适用场景（以下是清除所有元素的内外边距）
                    * {
                        margin: 0;
                        padding: 0;
                    }

        2、复合选择器（根据它们之间的特定关系来选取元素）
            （1）后代选择器：又称为包含选择器，可以选择父元素里的所有子元素。其写法就是外层标签写在前面，内层标签写在后面，中间用空格分隔。
                【语法】
                E1 E2 {样式声明}

                【语法说明】
                1）E1和E2中间用空格分开；
                2）E1是父级，E2是子级，最终选择是E2；
                3）E2即可以是儿子，也可以是孙子，只要是E1的后代即可 
                4）E1和E2可以是任意的基础选择器
            （2）子选择器：只能作为某一元素的最近一级子元素。简单理解就是选择亲儿子元素。
                【语法】
                元素1 > 元素2 {样式声明}

                【语法说明】
                1）元素1和元素2之间用>隔开；（可以无空格，有空格更规范）
                2）元素1是父级，元素2是最近的一级子级，最终选择的是元素2；
                3）元素2必须是亲儿子，其孙子、重孙之类的都不归他管
                4）E1和E2可以是任意的基础选择器
            （3）并集选择器：可以选择多组标签，同时为他们定义相同的样式。并集选择器是各级选择器中间用英文逗号隔开。
                【语法】
                元素1,
                元素2 {样式声明}

                【语法说明】
                1）元素1和元素2用逗号隔开，竖着写更加规范
                2）逗号可以理解为“和”的意思
                3）并集选择器通常用于集体声明
                4）E1和E2可以是任意的基础选择器
            （4）相邻兄弟选择器：匹配所有作为指定元素的相邻同级的元素
                【语法】
                元素1 + 元素2 {样式声明}

                【语法说明】
                1）第二个元素紧跟在第一个元素之后，并且两个元素都是属于同一个父元素的子元素
                2）E1和E2可以是任意的基础选择器
            （4）通用兄弟选择器：匹配属于指定元素的同级元素的所有元素
                【语法】
                元素1 ~ 元素2 {样式声明}

                【语法说明】
                1）匹配元素1的所有同级元素2，位置无须紧邻于第一个元素，只须有相同的父级元素。
                2）E1和E2可以是任意的基础选择器

        3、伪类选择器（指定选取元素的特殊状态）
            伪类选择器最大的特点就是用冒号表示。比如:hover 、:first-child
            （1）链接伪类选择器
                a:link 选择所有未被访问的链接
                a:visited 选择所有已被访问的链接
                a:hover 选择鼠标指针位于其上的链接
                a:active 选择活动链接（鼠标按下未谈起时的链接）

                【注意事项】
                1）为了确保链接伪类选择器生效，必须按照:link :visited :hover :active的顺序进行声明
                2）因为在浏览器会给<a>指定一个具有默认样式，即使父级元素有设置字体颜色，根据优先级的问题，继承的权重为0，<a>链接字体颜色为蓝色且有下划线。所以实际开发中需要给a单独指定样式
                3）a:hover设置样式时，如果此时设置的属性在原来的a中有，那么会进行覆盖。如果没有，原来a中的属性依然有效
            （2）:focus焦点伪类选择器：选取获得焦点的表单元素（焦点就是光标，一般情况只有<input>元素才能获取焦点，所以这个选择器主要真对表单元素）
                【语法】
                E:focus {
                    background-color: yellow;
                }
            （3）结构伪类选择器：根据文档结构来选择元素 （CSS3新增）
                :nth-child()
                ------------------------------------------------
                    选择符                描述
                    E:first-child       指定E的所有兄弟元素中的排在第一位且必须名为E的元素（E在所有兄弟元素中必须排第一个才有效）
                    E:last-child        指定E的所有兄弟元素中的排在最后一位且必须名为E的元素（E在所有兄弟元素中必须排最后一个才有效）
                    E:nth-child(n)      指定E的所有兄弟元素中排在第n位的且名为E的所有兄弟元素

                    （这里E必须是标签选择器）
                ------------------------------------------------
                    nth-child(n)根据元素在父元素的子元素列表中的索引来选择元素。
                        n可以是数字，关键字和公式。
                            1）n可以是数字，就选择里面的第n个兄弟元素
                            2）n可以是关键字：even偶数，odd奇数
                            3）n可以是公式：An+B。其中， n 为正整数或 0，A 和 B 为整数，且 A 不为 0
                    
                    【语法说明】
                    兄弟元素的计数包括任何元素类型的兄弟子元素。可以理解为同时满足两个条件，选择器就生效：
                        条件1：必须是E标签（这里的E必须是标签选择器，不可以是其它选择器）；
                        条件2：E标签必须在所有兄弟元素的位置和索引对应的上。

                :nth-of-chid()
                ------------------------------------------------
                    E:first-of-type     指定E的同名兄弟元素中的第一个
                    E:last-of-type      指定E的同名兄弟元素中的最后一个
                    E:nth-of-type(n)    基于同名兄弟元素中的位置来匹配元素

                    （这里E必须是标签选择器）
                ------------------------------------------------
                    
                
        4、伪元素选择器（利用CSS创建新标签，并设置其样式）（CSS3新增）
            ------------------------------------------------
                选择符              描述
                E::before           在元素内部的前面插入内容
                E::after            在元素内部的后面插入内容

                    （E可以是任意基础选择器，不写默认是通配符）
            ------------------------------------------------

                【语法说明】
                （1）before和after创建一个新元素，但是属于行内元素；
                （2）新创建的元素在文档树中是找不到的，所以称之为伪元素。
                    【伪元素与真实元素对比】
                        特性	                伪元素	            真实HTML元素
                        在DOM树中存在	        ❌ 不存在	        ✅ 存在
                        参与布局计算	        ❌ 不参与	         ✅ 参与
                        影响父元素尺寸	        ❌ 不影响	         ✅ 影响
                        影响文档流	            ❌ 不影响	        ✅ 影响
                        可通过JavaScript访问	⚠️ 有限访问	          ✅ 完全访问
                    【拓展·布局的计算过程】
                        浏览器渲染页面时：
                        1、解析HTML构建DOM树
                        2、解析CSS构建CSSOM树
                        3、组合DOM和CSSOM形成渲染树
                        4、计算布局（重排）
                        5、绘制页面
                        （伪元素在步骤3中被添加到渲染树，但在步骤4中不参与布局计算。）
                    【以下情况应使用真实HTML元素】
                        1、内容需要语义化意义
                        2、元素需要参与布局计算
                        3、需要JavaScript交互
                        4、内容对SEO重要
                        5、需要响应式调整大小和位置
                （3）before和after必须要有content属性。
                    如果未指定 content 属性、属性值无效或属性值为 normal 或 none，则不会渲染 ::after 伪元素
                    。其行为与设置了 display: none 相同。
                
            

        5、属性选择器（根据元素特定属性或属性值来选取元素，这样就可以不借助于类或id选择器）（CSS3新增）
            ------------------------------------------------
                选择符                描述
                E[arr]              选择具有arr属性的E元素
                E[arr="val"]        选择具有arr属性且属性值为val的E元素
                E[arr^="val"]       选择具有arr属性且属性值以val开头的E元素
                E[arr$="val"]       选择具有arr属性且属性值以val结尾的E元素
                E[arr*="val"]       选择具有arr属性且属性值包含val的E元素

                （E可是是任意一个简单选择器）
            ------------------------------------------------

        */

        /* 类选择器 */
        .color {
            color: rebeccapurple;
        }
        .star-sing {
            font-size: 15px;
        }
        /* id选择器 */
        #color {
            color: pink;
        }
        
        * {
            margin: 0;
            padding: 0;
        }

        /* 复合选择器 */
        /* 伪类选择器 */
        input:focus {
            background-color: white;
        }

        li {
            list-style: none;
        }


        /* CSS字体属性：fonts（字体）属性用于定义字体系列、大小、粗细和文本样式。
            1、字体系列：font-family。比如：
                p {
                    font-family: "微软雅黑";
                }
                div {
                    font-family: Arial,"\5B8B\4F53","Microsoft YaHei","微软雅黑";
                }

                【语法规范】
                （1）font-family 属性应包含多个字体名称作为“后备”系统，以确保浏览器/操作系统之间的最大兼容性。请以您需要的字体开始，并以通用系列结束（如果没有其他可用字体，则让浏览器选择通用系列中的相似字体）；
                    【常见通用字体】Microsoft YaHei / Hiragino Sans GB / Arial
                （2）各种字体之间必须用英文逗号隔开；
                （3）如果字体名称不止一个单词，则必须用引号引起来；
                （4）一般font-family属性直接给body标签使用。如：
                    body {
                        font-family: Arial,"Microsoft YaHei","微软雅黑";
                    }
                （5）有时候把中文字体名称用相应的Unicode编码代替，可以有效地避免浏览器解析CSS代码中的中文出现乱码的问题（浏览器兼容性问题）；
                    比如：
                        "\5B8B\4F53" 宋体
                        "\9ED1\4F53" 黑体
                        "\5FAE\8F6F\96C5\9ED1" 微软雅黑
            2、字体大小：font-size。比如：
                p {
                    font-size: 26px;
                }
                
                【语法规范】
                1）谷歌浏览器的默认字体大小是16px;
                2)不同浏览器可能显示的默认字体大小不同，我们尽量给一个明确大小，不要默认大小；
                3）可以给body指定整个页面文字的大小。而标题标签比较特殊，需要单独指定大小，通常情况下
                标题标签（h1-h6）本身也有默认的字体大小，这些默认值是相对于body的font-size设置而言的。
                例如，h1的字体大小是body的font-size的2倍，h2是1.5倍，以此类推。

            3、字体粗细：font-weight。比如：
                p {
                    font-weight: bold;
                }
                
                【语法规范】
                1）font-weight属性值
                    · 如果不声明，默认是normal。相当于number值为400
                    · 如果设置bold，那么字体加粗。相当于number值为700
                    · 设置数字，设置粗细，数字后没有单位。实际开发中，建议使用数字。
                2）若标签内的文字特别重要，建议使用<strong>标签
                3）使用场景：让加粗标签（如 h 和 strong 标签）不加粗，或让其他标签加粗。

            4、字体样式：font-style。如：
                p {
                    font-style: italic;
                }
                
                【语法规范】
                1）font-style属性值
                    · 默认为normal
                    · italic显示斜体
                2）适用场景：一般很少给文字加斜体。反而是让斜体标签（如em，i）不倾斜
                
            5、字体复合属性：为了更节约代码，可以把文字属性综合来写。如下：
                正常的 
                p{
                    font-style: italic;
                    font-weight: 700;
                    font-size: 16px;
                    font-family: "Microsoft YaHei";                  
                }  复合写法如下：
                p {
                    font: italic 700 16px/8px "Microsoft YaHei";
                }
                【语法规范】
                1）复合写法的font: font-style font-weight font-size/line-height font-family 
                必须按照这样的顺序来写属性值，否则无效。其中，行高有就写，没有就不写（不写显示为默认行高）
                2）不需要设置的属性可以省略（取默认值），但必须保留font-size和font-family属性，否则font属性无效
        */
        body {
            font-size: 16px;
        }

        h1 {
            font-size: 26px;
        }

        .font {
            font-style: italic;
            font-weight: 200;
            /* 
                复合写法：font: italic 200 16px "Microsoft YaHei";
            */
            text-align: center ;
        }

        /* CSS文本属性：定义文本的外观。比如文本的颜色、对齐文本、装饰文本、文本缩进、行间距等
            1、文本颜色：color
                【语法规范】
                1）属性值可以用三种方法表示
                    第一种：预定义的颜色值，如 red、blue、green、pink等等
                    第二种：十六进制(A～F,0～9一共十六个字符)，如 #FF0000、#FF6600等。
                    第三种：RGB代码，如rgb(255,0,0) 或 rgb(100%,0,0)
            2、文本对齐：text-align，用于设置元素内的文本水平对齐方式
                【语法规范】
                1）属性值：left(默认）、center、right
            3、装饰文本：text-decoration，规定添加到文本的装饰，可以是下划线、删除线、上划线等
                【语法规范】
                1）属性值
                    none （默认）没有装饰线
                    underline 下划线。<a>标签自带下划线
                    line-through 删除线
                    over-line 上划线
            4、文本缩进：text-indent，让文本的第一行缩进一个给定的长度（甚至可以是负值）。
                【语法规范】
                1）属性值：设置一个具体的数值。如
                    p {
                        text-indent: -10px;
                    }
                    有些情况下需要设置两个汉字的长度，可以将单位px换成em，如：
                    p {
                        text-indent: 2em;
                    } 
                    【说明】em是一个相对单位，就是当前元素(font-size)一个文字的大小，如果当前元素没有设置大小，则会按照父元素的1个文字大小
            5、行间距：line-height，控制行与行之间的距离
                【语法规范】
                1）属性值：设置一个具体的数值。如
                    p {
                        line-height: 26px;
                    }
                2）行间距是包含上间距、下间距和文字高度的。假设设置行高为26px，字体大小为16px，那么上下两行视觉上的间距是5px+5px=10px
                3) 行高是可以继承的，哪怕是行内元素。但是继承给行内元素，背景颜色不生效
        */

        /* CSS的引入方式  
        CSS的样式书写位置（或者引入的方式），CSS样式表分为三大类：
            1、行内样式表：在标签的内部设置style属性
                【说明】
                （1）style本身就是标签的属性
                （2）在双引号中间，写法要符合CSS书写规范
                （3）可以控制当前标签的样式
                （4）只有考虑对当前元素添加简单的样式的时候，才考虑使用
            2、内部样式表（嵌入式）：把CSS写到HTML页面内部，单独写到<style>标签中
                【说明】
                （1）理论上<style>标签可以放到HTML文档的任何地方，按一般会放到<head>标签中
                （2）此种方式，方便控制整个页面的元素样式设置
                （3）代码结构清晰，但没有实现结构与样式完全分离
            3、外部样式表（链接式）：实际开发中都是外部样式表。将CSS单独写到一个文件中，之后把CSS文件引入到HTML文档中使用
                【说明】
                （1）引入外部样式表分为两步：
                    第一步，新建后缀名为.css的文件，所有CSS代码都放入到此文件中
                    第二步，在HTML中使用<link>标签引入CSS文件。
                        <link rel="stylesheet" href="CSS文件路径">
                （2）引入CSS文件放在<head>中使用                 
        */
        
        /* emmet语法
        它的前身是 Zen coding，它是用缩写的形式来提高html/css的编写速度，vscode内部已经集成了该语法

        【快速生成HTML结构语法】
            1、生成标签：输入标签名按tab键
            2、生成多个相同标签：标签名*生成数量。比如div*3
            3、父子级标签：用>。比如ul>li (符号之间无空格)
            4、兄弟关系标签：用+。比如div+p (符号之间无空格)
            5、带有类名和id属性的标签：直接用标签名.demo或标签名#demo，不写标签名也可以，默认为div标签
            6、生成的div类名有顺序：用$自增符。比如.demo$*3
            7、生成标签内部直接有内容：用{}。比如div{我是示例} (符号之间无空格)
        【快速生成CSS样式语法】
            CSS样式基本采用简写形式即可。比如：
            1、width: 100px;  --->  w100
            2、text-align: center;  --->  tac
            3、text-indent: 2em;  --->  ti2em
        */
        
        /* CSS元素显示模式：即元素用什么方式进行显示，比如<div>自己占一行，<span>一行可以放多个

            一、HTML元素一般分为块元素和行内元素两种类型
                【块元素】
                    常见的块元素有ol、ul、h1~h6、div、p、li等

                    块元素的特点：
                    （1）比较霸道，自己独占一行，即使设置宽度不到容器的100%
                    （2）高度、宽度、内外边距都可以控制
                    （3）宽度默认是容器（父级宽度）的100%
                    （4）是一个容器及盒子，里面可以放行内元素和块元素
                        注意：文字类的元素内不可以放块元素。如<p>和<h1>~<h6>标签都主要用于存放文字，里面不能放块元素

                【行内元素】 也称内联元素
                    常见的行内元素有<a> <strong> <b> <em> <i> <del> <s> <ins> <u> <span>等

                    行内元素的特点：
                    （1）相邻行内元素位于一行上，一行可以有多个行内元素
                    （2）高、宽度直接设置是无效的
                    （3）默认宽度就是它本身内容的宽度
                    （4）行内元素只能容纳文本或其它行内元素（包括行内块元素）。
                        注意：1）链接<a>标签里面不能再放链接；
                            2）特殊情况链接<a>里面可以放块元素，但是给<a>转换一下块级模式更安全

                【行内块元素】
                    行内元素中有几个特殊的标签：<img /> <input /> <td>，他们同时具有块元素和行内元素的特点，所以也称为行内块元素

                    行内块元素的特点：
                    （1）相邻行内（这里特指行内块）元素位于一行上，但他们中间有空白间隙，一行可以有多个行内元素。
                        【拓展】空白间隙产生的原因
                            元素被当成行内元素排版的时候，元素之间的空白符（空格、回车换行等）都会被浏览器处理，根据
                            white-space的处理方式（默认是normal，合并多余空白），原来HTML代码中的 回车换行 被转成一个
                            空白符 ，所以元素之间就出现了空隙
                    （2）默认宽度就是它本身内容的宽度（行内元素特点），如果没有内容就不显示
                    （3）高度、宽度、内外边距都可以控制（块级元素特点）

            二、元素显示模式的转换
                特殊情况下，我们需要元素模式的转换。简单理解为：一个模式的元素需要另一个模式的特性。比如想要增加<a>元素的触发范围（可以理解为增加宽度和高度）
                
                【转换方式】
                （1）行内元素转化成块元素  display: block;
                （2）块元素转化成行内元素  display: inline;
                （3）转化成行内块元素   display: inline-block;
                    【注意】display:inline-block是让元素在一行显示，但是这些元素在html里面本来是上下行排列的，所以中间有换行符
                    ，于是并排显示就有了换行符带来的空隙

            补充：单行文字垂直居中显示
                CSS没有提供文字垂直居中的代码，可以用一个小技巧来实现，即：
                    【解决方案】设置文字的行高等于盒子的高度，就可以让文字在盒子内垂直居中
                    【原理】行高的上空隙和下空隙把文字挤到中间
        */
        .block {
            width: 200px;
            height: 200px;
            display: inline;
            background-color: aquamarine;
        }
        .inline-block {
            width: 200px;
            height: 30px;
            background-color: blue;
        }

        /* CSS背景   
        通过CSS背景属性，可以给页面元素添加背景样式。背景属性可以设置背景颜色、背景图片、背景平铺、背景图片位置、背景图像固定等。
            1、背景颜色 background-color
                【语法说明】
                （1）属性值默认是transparent(透明)，还可以设置一个颜色
            
            2、背景图片 background-image
                描述元素的背景图像。实际开放中常见logo或者一些装饰性的小图片或者是超大的背景图片，优点是非常便于控制位置（精良图也是一种运用场景）
                【语法说明】
                （1）属性值默认是none，还可以跟一个url(相对路径/绝对路径)。如：
                    background-image: url(images/img.png);
                （2）默认情况下，是平铺的，即大图（图片宽高超过盒子的宽高）不会缩小以适应盒子，小图则以平铺填充盒子
                （3）元素既可以添加背景颜色，也可以添加背景图片。如果同时添加，背景图片显示在背景颜色上层

            3、背景平铺 background-repeat（基于背景图片）
                如果需要在HTML页面上对图像进行平铺，会用到该属性
                【语法说明】
                1、属性值
                    repeat 背景图像横向纵向均平铺（默认值）
                    no-repeat 阻止背景图像重复平铺
                    repeat-x 背景图像横向平铺
                    repeat-y 背景图像纵向平铺

            4、背景图片位置 background-position （基于背景图片）
                改变图片在背景中的位置
                【语法说明】
                1、语法 background-position: x y;
                    其中，x和y分别代表x坐标和y坐标。即可以是“方位名词”，也可以是“精确单位”

                            方位名词            精确单位
                    纵向y轴  top                百分数
                            center             具体长度值，如10px
                            bottom 

                    横向x轴  left
                            center
                            right
                    
                    【注意】
                    （1）参数x和y都是方位名词：
                        1）前后顺序无所谓，比如 left top和top left效果一致。如：
                            background-position: center right; 等同于 background-position: right center;
                        2)如果只指定一个方位名词，第二个省略，则默认居中对齐
                    （2）参数x和y都是精确单位：
                        1）第一个肯定是x坐标，第二个是y坐标
                        2）如果指定了一个数值，那么该数值一定是x坐标，剩下的默认垂直居中
                    （3）参数x和y是混合单位，即两个数值是方位名词和精确单位的混合使用，那么：
                        1）第一个值肯定是x坐标，第二个值肯定是y坐标
            
            5、背景图像固定 background-attachment（基于背景图像）
                背景图像是否固定还是随着页面的其余部分滚动
                【语法说明】
                （1）属性值 
                    scroll 背景图像随内容滚动（默认值）
                    fixed  背景图像固定 

            6、背景颜色半透明
                【语法说明】
                （1）语法：background: rgba(0,0,0,0.3);
                    rgb分别对应red、green、blue，a对应alpha（透明度），取值范围在0~1之间（对应显示百分之多少）
                （2）习惯把0.3的0省略，写成.3。如background: rgba(0,0,0,.3);
                （3）背景颜色半透明指的是盒子背景半透明，盒子里面的内容不受影响

        
            补充：背景属性复合写法  （实际开发中更提倡）
                当使用简写属性时，没有特定的书写顺序，默认的也可以不写。一般习惯约定为：
                    background: 背景颜色 背景图片地址 背景平铺 背景图像滚动 背景图像位置; 
                    如：background: black url(images/img.png) repeat-y fixed top;
        */

        /* CSS的三大特性 
            【三大特性核心规则】
            1、层叠以及权重比较仅针对冲突属性
                （1）当多个选择器作用于同一元素时，浏览器会检查相同属性是否冲突。
                （2）对于冲突属性（如 color），权重高的选择器或权重相同靠后的选择器优先。
            2、非冲突属性直接合并
                （1）无论选择器权重如何，只要属性不冲突，所有声明都会叠加生效。

            一、层叠性
                相同选择器给设置相同的样式，此时一个样式就会覆盖（层叠）另外一个冲突的样式。层叠性主要解决样式冲突的问题

                【说明】
                （1）样式冲突遵循的是“就近原则”，哪个样式离结构近，就执行哪个样式。简单理解为，后来者居上
                （2）样式不冲突，不会层叠。即使样式属性一致，比如后面的设置了margin-top，前面的设置margin，此时只会覆盖margin-top，其他部分均不会覆盖

            二、继承性
                子标签会继承父标签的某些样式，如文本颜色和字号。

                【说明】
                （1）恰当的使用继承可以简化代码，降低CSS样式的复杂性
                （2）子元素可以继承父元素的样式有：text-,font-,line-这些元素开头的可以继承，以及color属性 
                （3）行高的继承性补充说明：
                    1）行高可以跟单位，也可以不跟单位。
                        （跟单位）
                            body {
                                font: 12px/24px "Microsoft YaHei";
                            }  
                        （不跟单位）
                            body {
                                font: 12px/1.5 "Microsoft YaHei";
                            }  
                        注意：不跟单位时，1.5代表的是当前font-size的1.5倍
                    2）如果子元素没有设置行高，那么会继承父元素的行高。
                        例子：假设父元素body设置
                            font: 12px/1.5 "Microsoft YaHei";、
                            子元素div单独设置font-size为16px，那么此时div的行高为16*1.5=24px

            三、优先级
                当同一个元素指定多个选择器，就会有优先级
                1、若选择器相同，则执行层叠性
                2、若选择器不同，则根据选择器权重执行：优先级高的选择器会被应用，即使其他选择器的顺序在他后面

                    ----------------------------------------------
                    （选择器）                      （选择器权重）
                    继承或 *                        0,0,0,0
                    元素选择器、伪元素选择器            0,0,0,1
                    类选择器、伪类选择器、属性选择器     0,0,1,0
                    ID选择器                        0,1,0,0
                    行内样式style=""                 1,0,0,0
                    !important重要的            ∞无穷大
                        【用法】当在一个样式声明中使用一个!important 规则时，此声明将覆盖任何其他声明。
                        虽然，从技术上讲，!important 与优先级无关，但它与最终的结果直接相关
                    -----------------------------------------------

                    【例子】
                    style中的样式设置如下：
                        #father {
                            color: black;
                        }        
                        p {
                            color: pink;
                        }
                    body中的结构是：
                        <div id="father">
                            <p>颜色是什么</p>
                        </div>
                    问：此时p的字体颜色是什么？
                    答：粉红色。因为继承的权重为0

                    【特别强调】若选择器不同，且涉及复合选择器，则会有权重叠加，需要计算权重。如：
                        div ul li ---> 0,0,0,3
                        .nav ul li  ---> 0,0,1,2
                        div::after ---> 0，0，0，2
                        a:hover ---> 0,0,1,1   (a:hover是复合选择器，标签+伪类)
                        .nav a ---> 0,0,1,1
                        div[class="clearfix"] ---> 0,0,1,1 (属性选择器是复合选择器，标签+属性)
                        
            
        */

        /* 盒子模型（Box Model) 这个部分里都是指默认的content-box
            所谓盒子模型，就是把HTML页面中的布局元素看作一个个矩形盒子，也就是盛装内容的容器。

            一、四大组成部分
                1、border边框：边框有三部分组成：边框宽度（粗细）、边框样式、边框颜色
                    【语法说明】
                    border: border-width || border-style || border-color
                    （1）该属性是复合属性，所以一般按照复合写法来简写。但是没有严格的顺序要求，一般是按照上面的写法来的。
                    （2）边框分开写法
                        1）设置单边的属性，如只设定上边框：
                            border-top: 2px solid pink;
                        2）设置边框颜色或边框宽度是按照上右下左的顺序
                            border-color: pink(上) green(右) black(下) red(左);
                    （3）border-collapse(表格的细线边框，也称边框合并）属性控制浏览器会值表格边框的方式。语法如下：
                        border-collapse: collapse;   (表示相邻边框合并在一起)
                        注意：假设不写这个，设置table,td {border: 1px solid pink};此时表示内部边框显示的是有两像素，因为盒子不会重叠
                    （4）border会影响盒子的实际大小。有两种方案解决盒子大小变化：
                        方案一：在实际开发中测量盒子的大小有两种方案：
                            第一，测量盒子大小的时候不量边框；
                            第二，测量盒子大小如果包含了边框，则设置实际的width/height为测量的width/height减去边框的宽度
                        方案二：改变盒子模型box-sizing: border-box;

                2、padding内边距：设置边框与内容之间的距离
                    【语法说明】
                    （1）padding是复合属性，分为padding-top,padding-bottom,padding-left,padding-right四个部分，所以可采用简写方式，根据值的个数表达意思：
                        
                        值的个数                            表达意思
                        padding: 5px;                      一个值，上下左右内边距都是5px
                        padding: 5px 10px;                 两个值，上下内边距分别是5px，左右内边距分别为10px
                        padding: 5px 10px 20px;            三个值，上内边距是5px，左右内边距是10px，下内边距是20px
                        padding: 5px 10px 15px 20px;       四个值，上内边距是5px，右内边距是10px，下内边距是15px，左内边距是20px（顺时针）
                    （2）padding会影响盒子的实际大小。有两种方案解决盒子大小变化：
                        方案一：在实际开发中测量盒子的大小解决方案如下：
                            【解决方案】测量盒子的大小包含了padding，则设置实际的width/height为测量的width/height减去padding的宽度
                        方案二：改变盒子模型box-sizing: border-box;
                    （3）如果盒子没有指定width/height属性，此时padding不会撑开盒子大小。换句话说，视觉上不生效（代码并无错误）
                    （4）padding不可以直接取auto值，只能取长度值（像素或百分比）

                3、margin外边距：控制盒子与盒子之间的距离
                    【语法说明】
                    （1）margin是复合属性，分为margin-top,margin-bottom,margin-left,margin-right四个部分，所以可采用简写方式，根据值的个数表达意思：
                        
                        值的个数                            表达意思
                        margin: 5px;                      一个值，上下左右外边距都是5px
                        margin: 5px 10px;                 两个值，上下外边距分别是5px，左右外边距分别为10px
                        margin: 5px 10px 20px;            三个值，上外边距是5px，左右外边距是10px，下外边距是20px
                        margin: 5px 10px 15px 20px;       四个值，上外边距是5px，右外边距是10px，下外边距是15px，左外边距是20px（顺时针）
                    （2）一般利用外边距设置块级盒子水平居中，但是有两个前提：
                        前提1:盒子必须指定了宽度(width)
                        前提2:盒子左右的外边距都设置auto
                    
                        以下几种写法都可以：
                        1）margin-left:auto;  margin-right: auto;
                        2）margin: auto;
                        3）margin: 0 auto;

                        【注意】上面的方式是让块级元素水平居中，那么让块级元素或表单单元格内的行内元素和行内块元素水平居中的方式可以是给其父元素添加text-align: center即可
                    （3）相邻块元素垂直外边距合并问题：当上下相邻的两个块元素（兄弟元素）相遇时，如果上面的元素设置了上外边距，下面的元素设置了上外边距，则他们之间的距离不是两个边距之和
                    ，而是取两个值中大的外边距。
                        【注意】水平方向不会发生
                        【解决方案】只给一个盒子设置margin值
                    （4）嵌套块元素垂直外边距的塌陷：对于两个嵌套关系（父子关系）的块元素，只要子元素设置一个外边距，无论父元素是否设置，此时父元素会塌陷父子中较大的外边距值，
                    而子元素本应该和父元素之间有个距离，也不会显示，如下方html结构在浏览器中的效果。
                        【解决方案】
                        1）给父元素定义上边框
                        2）给父元素定义上内边距
                            实际操作有两种：第一种，父元素添加内边距为很小的值，如1px，起到阻隔的作用；
                                        第二种，子元素不设置上外边距，直接给父元素设置上内边距等于子元素要设置的上外边距的值
                        3）为父元素添加 overflow:hidden
                        4）子元素不定义外边距，改成定义内边距
                    （5）清除内外边距：网页很多元素都有默认的内外边距，但不同浏览器默认的值也不一致，所以在布局前需要使用通配符选择器清除网页元素默认的内外边距
                        * {
                            margin: 0;
                            padding: 0;
                        }
                    （6）行内元素为了兼容性，尽量只设置左右内外边距，不要设置上下内外边距（因为不兼容的话设置了也不会生效）。但是转换成块级元素和行内块元素就可以了
                            ---------------------------------------------------------------------
                                    宽高        内边距          边框            外边距          行高
                            ----------------------------------------------------------------------
                            块盒     有效        有效           有效            有效            有效
                            -----------------------------------------------------------------------
                            行盒     有效       水平有效        水平有效         水平有效         有效
                                            ，垂直不占空间   ，垂直不占空间    ，垂直不占空间   （不影响背景）
                            -----------------------------------------------------------------------                 
                            行块盒    有效         有效        有效        有效      有效        有效
                            ----------------------------------------------------------------------

                4、content内容
        */
        .f-margin {
            width: 400px;
            height: 400px;
            background-color: blueviolet;
            margin-top: 30px;
            padding-top: 50px;
        }
        .f-margin div {
            background-color: aquamarine;
            /* margin-top: 50px; */
        }
        /* CSS3盒子模型
        CSS3中可以通过box-sizing来指定盒子模型，有两个值：content-box和border-box，这样计算盒子大小的方式就发生了改变
            1、box-sizing: content-box;盒子大小为 width + padding + border(默认)
            2、box-sizing: border-box;盒子大小为 width
        */

        /* 圆角边框 border-radius：使盒子变成圆角 （CSS3新增）
            【原理】半径radius的圆与边框的交集成圆角效果。要注意的是，border-radius是基于盒子的大小成交集
                ，所以即使没有设置边框，border-radius也是可以作用的。
            【语法说明】
            1、语法：border-radius: length;
                参数值可以是具体数值，也可以是百分比
            2、应用
                （1）如果是正方形，想要一个圆，只要把数值设置成高度或宽度的一半即可，或直接写50%
                （2）如果是长方形，想要两边是半圆，只要把数值设置成高度的一半即可
            3、该属性是一个简写属性，可以跟四个值，分别代表左上角、右上角、右下角、左下角  
            4、
        */

        /* CSS阴影效果
        
        一、盒子阴影 box-shadow (CSS3新增)
            【语法说明】
            1、语法：box-shadow: h-shadow v-shadow blur spread color inset;
                h-shadow 必须。水平阴影的位置。允许负值
                v-shadow 必须。垂直阴影的位置。允许负值
                blur 可选。模糊距离（虚实程度）
                spread 可选。阴影的尺寸（阴影的大小）
                color 可选。阴影的颜色
                inset 可选。将外部阴影(outset)改成内部阴影
            
        二、文字阴影 text-shadow    (CSS3新增)
            【语法说明】
            1、语法：text-shadow: h-shadow v-shadow blur color;
                h-shadow 必须。水平阴影的位置。允许负值
                v-shadow 必须。垂直阴影的位置。允许负值
                blur 可选。模糊距离（虚实程度）
                color 可选。阴影的颜色
        */

        /* CSS浮动

        传统网页布局的三种方式（简单说，盒子如何进行排列的？）：
            1、标准流（普通流）：不对页面进行任何布局控制时，标签按照默认规定好的HTML布局方式进行排列。如：
                （1）块级元素独占一行，从上至下按顺序排列；
                （2）行内元素从左到右依次排列，碰到父元素边缘自动换行；
            2、浮动
                （1）为什么需要浮动？
                    有很多的布局方式，依靠标准布局流无法完成（比如最常见的“让多个块元素一行内排列显示），此时就可以利用浮动来完成
                    。浮动可以改变标签的默认排列方式
                （2）什么是浮动？
                    float属性用于创建浮动框，将其移动到一边，知道左边缘或者右边缘触及父级块元素或另一个浮动框的边缘
                    
                    【语法说明】
                    1）语法：float：属性值;
                        属性值          描述
                        none            元素不浮动（默认值）
                        left            元素左浮动
                        right           元素右浮动
                    2）浮动特性
                        1、浮动元素会脱离标准流（脱标）。它不会保留原先的位置，视觉上是浮动元素置于浮动元素后方标准流元素之上，两者重叠，但
                            浮动元素的文字不会压住标准流的文字，并且如果此时父元素设置text-align：center，环绕在浮动元素周围的text-align依然是
                            生效的，即以父元素扣掉浮动元素后剩下的空间为参考居中。如“CSS三角实现梯形价格对比”例子中父元素设置文本居中后，环绕文字居中生效。
                        2、浮动元素会一行内显示并且元素顶部对齐。如果父级元素装不下浮动的盒子，多出的盒子会另起一行对齐
                        3、任何元素都可以浮动，不管原先是什么模式的元素，添加浮动之后都具有行内块元素的特性(computed里display为块元素）。
                            第一，可以直接设置宽高。比如：<span>标签直接设置width/height无效
                                但是，如果添加了float属性，就像行内块元素一样。而不需要再给<span>标签添加 display:inline-block;
                            第二，添加float属性，如果不单独设置宽度，元素的宽度默认为内容的宽度
                            第三，浮动元素之间没有空隙
                            第四，浮动的盒子不会造成外边距合并问题
                            第五，浮动的盒子是在父元素的content里
                    3）浮动元素通常搭配标准流的父元素使用，否则浮动元素会以body为父元素置于浏览器页面正上方
                    4）一个元素浮动了，理论上其余的兄弟元素也要浮动，以防止出现问题（比如浮动元素的文字不会压住标准流的文字）
                    5）无论是浮动还是定位，只要是脱离了文档流的块级元素，如果不设置宽度，它会从默认宽度100%变成收缩适应内容auto。

                （3）为什么清除浮动？
                    正常的标准流，块级父元素可以不设置高度，此时父元素的高度由子元素决定。但是很多时候父元素不方便给高度
                    ，此时子元素都设置浮动，则此时父元素的高度为0。实际开发中，父元素后方的标准流的兄弟元素会代替它原本应
                    该在的位置。所以，清除浮动就是清除浮动导致没有设置高度的父元素脱离标准流的影响。

                    【语法说明】
                    语法：clear:属性值;
                        属性值           描述
                        left           左侧不允许有浮动元素
                        right          右侧不允许有浮动元素
                        both           左右均不允许有浮动元素
                    
                    【清除浮动方法】
                    1、额外标签法，也称隔墙法(不常用)
                        在浮动元素的后面再添加一个空的标签。例如<div style="clear:both;"></div>或者其它标签(如<br/>等)
                        
                        【注意】添加的标签必须是块级元素，不能是行内元素
                            
                            优点：通俗易懂，书写方便
                            缺点：添加无意义的标签，结构性差
                    2、父级元素添加overflow
                        可以给父级元素添加overflow属性，其属性值设置为auto、hidden、scroll
                        
                            优点：代码简洁
                            缺点：无法显示溢出的部分
                    3、:after伪元素法（额外标签法的升级版，是给父级元素添加）
                        优点：没有增加标签，结构更简单
                        缺点：需要照顾低版本浏览器

                        .clearfix:after {
                            content: "";
                            display: block;   
                            height: 0;
                            clear: both;
                            visibility: hidden;
                        }
                        .clearfix {  
                            *zoom: 1;
                        }   IE6、7专有
                            【说明】同时设置 visibility: hidden 和 height: 0解决了不同浏览器下的兼容性问题
                                旧浏览器兼容性问题：
                                    在IE6/7等旧浏览器中，即使高度为0的元素仍可能占据布局空间
                                    设置visibility: hidden可以确保元素完全不影响布局
                                
                            
                    4、双伪元素清除浮动（也是给父元素添加）
                        .clearfix:before, .clearfix:after {
                            content: "";
                            display: table;  转化成块元素且一行显示。如果仅转化成block，前后块元素占两行，上下显示
                        }
                        .clearfix:after {
                            clear: both;
                        }
                        .clearfix {  
                            *zoom: 1;
                        }   IE6、7专有
                            
                            优点：没有增加标签，结构更简单
                            缺点：需要照顾低版本浏览器

            3、定位
                将一个盒子摆在某一个位置，所以定位就是摆放盒子，按照定位的方式移动盒子。

                （1）为什么需要定位？
                    答：定位可以让盒子自由地在某个盒子内移动位置或者固定在屏幕中某个位置，并且可以压住其他盒子。简而言之
                    ，就是创建一个固定在页面其他部分顶部的 UI 元素，并且/或者始终停留在浏览器窗口内的相同位置
                （2）定位组成
                    定位 = 定位模式 + 边偏移

                    （一）定位模式：定位模式决定了元素的定位方式，它通过CSS的position属性设置，其值可以分为四个：
                        
                            属性值              语义
                            static            静态定位（每个元素都有的默认值）
                            relative          相对定位
                            absolute          绝对定位
                            fixed             固定定位

                        1、静态定位  position：static;
                            【语法说明】
                            1）静态定位按照标准流特性摆放位置，没有边偏移，是默认的定位方式。换句话说，理解为“无定位”即可
                            2）静态定位在布局中很少用到
                        2、相对定位  position: relative;
                            【语法说明】
                            1）相对定位是相对它原来的位置进行移动的
                            2）原来在标准流的位置继续占有，后面的盒子仍然按照标准流的方式对待原来的位置（不脱标，保留原来的位置）
                            3）现在的位置压在原来整个页面之上，不影响标准布局流，即使是文本也会压住标准流的文字（区别于浮动）
                        3、绝对定位  position: absolute;
                            【语法说明】
                            1）绝对定位是相对它的祖先元素来进行移动的。
                            2）如果没有祖先元素，则以浏览器为准定位（Document文档，非<body>元素）。 
                                【问题】哪个元素是绝对定位元素的“祖先元素“？
                                答：这取决于绝对定位元素的父元素的 position 属性。如果所有的父元素都没有显式地定义 position 属性，
                                那么所有的父元素默认情况下 position 属性都是 static。结果，绝对定位元素会被包含在初始块容器中。这个
                                初始块容器有着和浏览器视口一样的尺寸，并且<html>元素也被包含在这个容器里面。简单来说，绝对定位元素会被
                                放在<html>元素的外面，并且根据浏览器视口来定位（窗口即使缩放，定位也随之变化）
                            3）祖先元素是有定位的，无论是相对、绝对还是固定定位，以最近的一级的有定位的祖先元素为参考位置进行移动
                            4）绝对定位脱标，原来的位置不再继续占有，同时现在的位置也不会影响标准布局流包括文本
                            5）子级是绝对定位的话，如果没有合适的祖先元素，需要定义上下文安排一个祖先元素，此时给理想的祖先元素设置position:relative;
                            6）脱离了文档流的盒子是无法通过margin: 0 auto;设置水平居中的。如何实现（竖直方向同理）：
                                第一步：设置left：50%;
                                第二步：设置margin-left为自身宽度的负一半
                            7）不管原先是什么模式的元素，添加绝对定位和固定定位之后都具有行内块元素的特性(computed里display为块元素）。
                                比如，行内元素可以直接设置宽高；无论是原先是行内元素还是块元素，现在的宽度默认都变成内容的宽度。
                            8）无论是什么定位，区别于浮动的是：定位元素的文字会压住标准流的文字，而浮动元素的文字不会压住标准流的文字。因为浮动
                            产生的目的就是文字环绕。
                                
                        4、固定定位  position: fixed;
                            固定定位是元素固定于浏览器的可视位置。主要使用场景：可以在浏览器页面滚动时，元素位置不变

                            【语法说明】
                            1）以浏览器的可视窗口为参考点移动；
                            2）和父元素没有任何关系；
                            3）不随滚动条滚动
                            4）固定定位脱标，不占有原先的位置，可以当成一种特殊的绝对定位。
                                【小技巧补充】
                                1、固定定位脱标，块元素宽度变成auto，如果要使其以原始宽度布局。可以设置左右边距为0进行拉伸：
                                        .position {
                                            position: fixed;
                                            left: 0;
                                            right: 0;
                                        }
                                2、 固定到版心右侧，具体做法：
                                    第一步，让固定定位的盒子定位的left:50%，处于浏览器正中央；
                                    第二步，给固定定位的盒子设置margin-left的数值为版心距离的一半。
                                        【说明】除粘性定位以外的定位，上下左右距离都是从外边距开始算的，而不是边框
                        
                        5、粘性定位  position: sticky;
                            粘性定位是固定定位和相对定位的混合

                            【语法说明】
                            1）以浏览器的可视窗口为参考点移动（固定定位特点）
                            2）粘性定位占有原先的位置（相对定位特点）
                            3）必须添加top、bottom、left、right其中一个才有效
                            4) 粘性定位的上下左右距离是从边框开始算的
                        
                    （二）边偏移：边偏移就是定位的盒子移动到最终位置。有top、bottom、left和right4个属性
                            
                            属性                示例                描述
                            top             top:80px               顶端偏移量，定义元素相对其父元素上边线的距离
                            bottom          bottom:80px            底端偏移量，定义元素相对其父元素下边线的距离
                            left            left:80px              左端偏移量，定义元素相对其父元素左边线的距离
                            right           right:80px             右端偏移量，定义元素相对其父元素右边线的距离
                (3）定位叠放次序 z-index
                    在使用定位布局时，可能会出现盒子重叠的情况。此时，可以使用z-index来控制盒子的前后次序(z轴)
                    【语法说明】
                    1）属性值可以是正整数、负整数或0，默认是auto，数值越大，盒子越靠上
                    2）如果属性值相同，则按照书写顺序，后来者居上
                    3) 该属性仅限定位元素生效
                    4）如果没有设置 z-index，或者 z-index 值相同，那么在文档流中靠后的元素会覆盖在靠前的元素之上。
            
            【注意】
            （1）实际开发中，一个页面基本都包含了这三种布局方式（后面移动端学习新的布局方式）
            （2）网页布局第一准则：多个块级元素纵向排列找标准流，横向排列找浮动       
        */
        .absolute {
            position: absolute;
            bottom: 20px;
            right: 30px;
            width: 300px;
            height: 300px;
            background-color: pink;
        }
        .absolute div {
            position: absolute;
            top: 50px;
            left: 50px;
            width: 100px;
            height: 100px;
            background-color: red;
        }

        /* 元素的显示与隐藏 ———— 让一个元素在页面中显示或隐藏起来
            1、display 属性
                （1）display: none; 隐藏元素
                    【语法说明】
                    1）display: none; 通常与 JavaScript 一起使用
                    2）表示从文档中隐藏元素，因为浏览器解析后的文档结构中依然保留在，但不再占有原来的位置
                    3）不再占有原来的位置，同时也无法进行交互。比如鼠标滑过的时候:hover 无法生效
                （2）display: block; 除了转换成块级元素之外，还有显示元素的意思
            2、visibility(可见性) 属性
                （1）visibility: visible; 元素可视
                （2）visibility: hidden; 隐藏元素
                    【语法说明】
                    1）隐藏元素后，继续占有原来的空间
                    2）占有原来的位置，但无法进行交互。比如鼠标滑过的时候:hover 无法生效
            3、overflow(溢出) 属性
                overflow属性指定了如果内容溢出一个元素的框（超过其指定高度及宽度）时，会发生什么
                （1）overflow: hidden; 溢出的部分隐藏
                    【注意事项】如果有定位的盒子，其父元素慎用overflow:hidden，因为可能会隐藏定位元素的一部分
                （2）overflow: scroll; 显示滚动条，防止溢出，即使不溢出也显示
                （3）overflow: auto; 溢出时，溢出的部分显示滚动条；不溢出时，不显示滚动条
        */
        .potato {
            position: relative;
            width: 444px;
            height: 320px;
            margin: 0 auto 30px;
        }
        .potato img {
            width: 100%;
            height: 100%;
        }
        .mask {
            visibility: hidden;
            /* display: none; */
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,.4) url(images/arr.png) no-repeat center;
        }
        /* visibility和display都无法交互，所以定义当鼠标悬停在 .potato（父容器）上时，显示.mask */
        /* 鼠标交互可以直接给任何html元素使用，非仅限于a标签 */
        .potato:hover .mask {
            visibility: visible;
            /* display: block; */
        }

        /* overflow
            overflow 属性未设置或设置为 visible (默认值)。在这种情况下，子元素会溢出父
            元素，并且在页面上可见。溢出的部分会显示在父元素之外，可能导致页面布局错乱。
        */

        /* vertical-align 
        使用场景：通常用于设置图片、表单（行内块元素）和文本的垂直对齐。
        【语法说明】
        1、只对行内元素或行内块元素有效

        【常见问题】
        场景
            当图片包含在一个块级容器内时（块级容器不设置高度，此时默认高度为内容的高度），容器底部也就是图片下方会出现一个空白间隙】
        
        原因
            即使容器内只有一张图片，容器也会被视为一个行框（line box），行框的高度由内部元素的最高点到最低点决定。由于图片
            （`<img>`）是内联替换元素（inline-replaced element），其默认的`vertical-align`属性值为`baseline`，基线对齐预留了
            空间以容纳可能存在的字母（如g, j, p, q等）的下沉空间，基线下方会保留一定的空间（称为strut），这个空间就是间隙的来源。
            （见下方结构中的动画演示）
        
        解决方案：如何完全消除下伸空间的影响？
            （1）（常用）如果图片单独在一个容器中，将图片设置为块级元素display: block;，彻底消除内敛元素默认基线对齐的影响
            （2）（常用）如果图片和文本混排，设置vertical-align: top | bottom | middle | text-top | text-bottom ，彻底消除内敛元素默认基线对齐的影响
            （3）如果图片单独在一个容器中，设置图片浮动，消除图片作为内敛元素基线对齐的影响
            （4）如果图片单独在一个容器中，给父元素设置一个高度等于图片的高度，而溢出部分隐藏
            （5）如果图片单独在一个容器中，可以设置line-height: 0;且font-size: 0;因为img是替换元素，不受两个属性的影响，而完全避免了浏览器此时以为
            存在文本，而保留文本的下伸空间的影响。
                【拓展延伸】
                1）默认情况下，行内元素的line-height属性只影响元素内部文本的垂直对齐，不会有上下边距。
                2）单独设置`font-size: 0`：这样会消除字体本身的下伸空间，因为字体大小为0，所以字体度量中的下伸部分也为0。但是，行框的高度可能还受行高的影响。
                    如果行高是正常的（比如`line-height: normal`），那么行框高度可能不为0（因为不同浏览器对于`font-size:0`的行高计算可能不同）。所以，为了
                    确保行框高度为0，通常需要同时设置`line-height:0`。

                    单独设置`line-height: 0`：行高为0会强制行框的高度为0（即使字体大小不为0）。但是，如果字体大小不为0，那么字体本身的下伸空间仍然存在，但由于
                    行框高度为0，这些下伸部分会溢出到行框外面（可能被父容器裁剪，也可能不可见，取决于父容器的`overflow`设置）。所以，单独设置`line-height:0`并
                    不能保证消除下伸空间的影响，因为下伸部分可能溢出。

                    因此，为了确保消除下伸空间的影响（即让行框高度为0，并且不出现溢出的下伸部分），通常需要同时设置：
                        font-size: 0;
                        line-height: 0;
                    这样，行框高度为0，并且字体大小为0，下伸空间自然为0，也就不会出现任何下伸空间的影响。但是，在某些情况下，我们可能只需要设置其中一个属性就能达
                    到效果。例如，如果父容器设置了`overflow: hidden`，那么单独设置`line-height:0`可能就足够了，因为溢出的下伸部分会被裁剪掉。然而，为了跨浏
                    览器的一致性，通常建议同时设置行高和字体大小这两个属性。



        【拓展】
            一、文本保留空间
                1、下伸空间计算公式
                    下伸空间≈字体大小(font-size)×0.3×行高因子(line-height factor)
                        其中， 行高因子=line-height/font-size
                2、即使容器内没有文本，行框仍会保留这个空间
            二、行框（Line Box）计算机制
                什么情况下容器会被认为是一个行框？
                    实际上，容器本身不会变成行框，而是容器内的内容会生成行框。具体来说：
                    1、生成条件：当块容器中的内容为内联级别时，这些内容会被排列在行框中。一行放不下则换行，形成多个行框。如果容器内近块级元素，不生成行框
                    2、高度计算：行框的高度由该行内所有内联元素中最高者和最低者之间的垂直距离决定。具体来说，行框的顶部位于该行内所有元素的最高顶边，底部位于最低底边。
                        【计算公式】
                            行框高度 = max(所有内容视觉最顶部) - min(所有内容视觉最底部)
                                    + 行高导致的额外空间（如果max-min包含了行高额外空间，则不需要再额外计算）
                                    + 文本下沉空间（如果max-min包含了下半间距，则不需要再额外计算）
                        【注意】
                        （1）行框会为下沉字符预留空间（即使没有实际字符）
                        （2）行框高度和行高line-height的区别：
                            ··  行高是设置值，行框高度是计算值。行高是定义行于行之间的垂直距离(行间距)，而行框是虚拟的，不可直接设置，它由浏览器自动计算和调整（视觉显示）。行高是设置文本行高度的属
                                性，而行框高度是行内元素在垂直方向上所占据的空间大小。
                            ··  行框的高度受 line-height 属性、内联元素的高度（如图片、文本）以及垂直对齐方式等因素的影响。正常情况下，如果行内元素全部是文本，
                                行框高度基本等于line-height
                    3、垂直对齐：行框内的每个内联元素根据其`vertical-align`属性进行垂直对齐。默认是基线（baseline）对齐。
                    4、水平排列：内联元素在行框内水平排列，方向由`direction`和`writing-mode`决定（默认从左到右）。
                    5、换行：当内容超过容器宽度时，会自动换行，形成新的行框。换行行为受`white-space`属性控制。
                    6、包含关系：一个块容器可能包含多个行框（多行文本），每个行框都是其容器的一个子矩形区域。
        */

        /* 精灵图 & 字体图标

        （精灵图）
            一、为什么需要精灵图？
                一个网页中往往会应用很多小的背景图像作为修饰，当网页中图像过多时，服务器就会频繁地接收和发送请求图片
                造成服务器请求压力过大，造成网页加载速度降低。因此，为了有效地减少服务器接收和发送请求的次数，提高页面
                的加载速度，出现了CSS精灵技术（也称 CSS Sprites、CSS雪碧）。

            二、精灵图核心原理
                精灵图技术主要针对背景图片使用，就是把多个小背景图片整合到一个大图片中，这个大图片也称为Sprites 精灵
                图或雪碧图，这样浏览器只需要请求一次就可以了

            三、精灵图使用
                1、移动背景图片的位置，此时使用background-position即可
                2、使用精灵图的时候需要精确测量每个小背景图片的位置和大小
                3、一半情况下设置精灵图的background-position用的精确单位是负值（X轴右为正左为负，Y轴下为正，上为负）
        
        （字体图标）
            精灵图优点很明显，但是缺点同样也很明显，比如：
                （1）图片文件还是比较大的；
                （2）图片放大或缩小会失真；
                （3）图片一旦制作完成，想要更换非常复杂。
            此时，字体图标 iconfont 的出现很好的解决了以上问题。但是，字体图标不能替代精灵技术，针对结构和样式特别简单的
            小图标，可以用字体图标；针对结构和样式比较复杂的小图片，只能通过精灵图
            
            【字体图标iconfont说明】
            1、主要适用于显示网页中通用的、常用的一些小图标。加载原理和精灵图相同，减少请求次数，只需要向服务器请求一次
            2、iconfont的优点
                （1）轻量级：一个字体图标比一系列的图像要小。一旦字体加载了，图标马上就会渲染出来，减少了服务器的请求
                （2）灵活性：展示的是图标，本质是文字。也就是说，可以随意变换大小、颜色、阴影、透明效果、旋转等
                （3）兼容性：几乎支持所有的浏览器
            3、iconfont的使用
                （1）字体图标的下载
                    推荐网站：icomoon、阿里iconfont字库
                （2）字体图标的使用
                    1）网站上下载字体图标之后，文件里的内容不要删除，都会使用。其中，最重要的就是fonts文件夹；
                        （补充）fonts中包含4个字体文件，是因为不同浏览器支持的字体格式不同，所以放上了不同浏览器所支持的字体文件
                    2）把fonts文件夹放到页面的根目录下(和“字体图标引入”中第二步的字体声明中的路径对应上，避免修改路径，省去麻烦)
                    3）字体图标的引入
                        第一步，在CSS样式中全局声明字体：简单理解为把这些字体文件通过CSS引入到页面中
                        第二步，如何声明？找到下载后的文件，复制style.css中的第一段声明到CSS文件或<style>中，可以全局声明图标字体
                        第三步，在html标签中加入小图标或对应的Unicode编码。小图标和Unicode编码可以从下载的文件中的demo.html中复制得到
                        第四步，给添了图标的html标签对应的样式设置字体系列和第二步中的字体声明的字体系列一致 
                    4）字体图标的追加，如果工作中字体图标不够用了，把下载文件中的selection.json文件重新上传，然后增加自己想要的新图标
                        ，重新下载压缩包即可
        */
        .sprites {
            width: 64px;
            height: 57px;
            background: url(images/sprites.png) no-repeat -183px 0;
        }
        .icon {
            font-family: icomoon;
            font-size: 16px;
        }

        /* CSS三角
            【具体实现】
            设置宽高为0的盒子，并指定边框为透明色，给需要的三角形添加颜色即可。代码如下：
                div {
                    width: 0;
                    height: 0;
                    line-height: 0;  // 为了照顾兼容性问题
                    font-size: 0;   // 为了照顾兼容性问题添加
                    border: 1px solid transparent;
                    border-top-color: pink;
                }
            【注意】当宽高为0时候，border至少要相邻两条边挤一挤才会生效。

            【补充说明】
                在 IE6/7以及旧版Firefox 中可能会为内联元素保留一定的“行框”空间，即使内容为空。这是因为这些浏览器在计算
                元素盒模型时，可能会考虑添加默认行高（line-height）和字体大小（font-size）带来的空白，即使元素内部没有内容。
                所以，当我们创建一个CSS三角形（本质上是利用边框）时，这些额外的空间可能会在元素周围出现。

                而浏览器默认给下伸文字保留空间，两个问题的共同点在于它们都涉及浏览器对不可见或潜在空间的保留，但触发
                机制和上下文不同。CSS三角形问题是旧浏览器对空元素的错误处理，属于浏览器bug。下伸文字问题是CSS行框布局的标准
                行为，属于设计特性
                
                在CSS三角形中，通过设置`line-height:0`和`font-size:0`来告诉旧版浏览器：这个元素不应该有任何
                由文本行高或字体大小带来的额外空间。这样，元素就只由边框构成，从而确保三角形周围没有多余的空间。

                而在下伸文字的问题中，我们通常通过改变对齐方式（如`vertical-align`）或调整行高、字体大小来消除空
                间，来消除下伸部分。

            【案例：京东三角】
                定位 + CSS三角实现京东的鼠标滑动后出现的区域由三角形带出

            【案例：CSS三角实现梯形价格对比】
                见结构中
        */
        .triangle {
            width: 0;
            height: 0;
            border: 50px solid transparent;
            border-bottom-color: greenyellow;
        }

        /* 鼠标样式 cursor
        设置或检索在对象上移动的鼠标指针采用何种系统预定义的光标形状

            属性值                      描述
            default                    小白（默认）
            pointer                    小手
            move                       移动
            text                       文本
            not-allowed                禁止
        */

        /* 表单轮廓去除 & 防止拖拽文本域
        给表单元素添加outline: 0或者outline: none之后，就可以去除获取焦点后默认的蓝色边框
        给文本域添加resize: 0就可以防止拖拽文本域
        
        */
        input {
            outline: 0;
        }

        /* 一、单行文字溢出显示省略号
            单行文字溢出显示省略号必须满足三个条件：
                条件1：先强制一行内显示文本
                    white-space: nowrap; (默认normal自动换行)
                条件2：超出的部分溢出隐藏
                    overflow: hidden;
                条件3：文字用省略号代替溢出的部分
                    text-overflow: ellipsis;
            
            二、多行文字溢出显示省略号
            多行文字溢出显示省略号有较大的兼容性问题，适用于webkit浏览器或移动端(移动端大部分浏览器是webkit内核)。所
            以，实际开发中，更推荐后端人员去实现
                【语法】
                    overflow: hidden;
                    text-overflow: ellipsis;
                    display: -webkit-box;   //弹性盒子模型显示
                    -webkit-line-clamp: 2; //限制一个块元素显示的文本行数
                    -webkit-box-orient: vertical;  //设置或检索伸缩盒对象的子元素的排列方式   
        */

        /* CSS初始化
            看京东CSS初始化做了哪些设置, 见"京东CSS初始化.css"文件 
        */

        /* CSS3的现状以及常见新增特性
        一、CSS3的现状
            1、CSS3新特性具有兼容性问题，在IE9+浏览器中才支持；
            2、移动端支持优于PC；
            3、不断改进中；
            4、应用相对广泛；

        二、滤镜 filter    
            将模糊或颜色偏移等图形效果应用于元素。
            【语法】
                filter: 函数(); 
                    例如 filter: blur(5px); "blur"模糊处理，数值越大越模糊

        三、calc函数
            此CSS函数让你在声明CSS属性值的时候执行一些计算。
                比如: width: calc(100% - 50px);
                    【注】
                    (1)括号里可以用 + - * / 来进行计算。加减运算符两侧必须有空格，乘除运算符则不需要。
                    (2)CSS不支持括号里使用变量，如果需要动态计算结合js使用

        四、过渡 transition
            过渡transition是CSS3中最具颠覆性的特征之一，我们可以在不使用flash动画或者javascript的情况下
            ，当元素从一种样式变成另外一种样式时为元素添加效果。

            【语法说明】
            1、语法： transition: 要过渡的属性 花费时间 运动曲线 何时开始;
                (1) 想要过渡的属性： 大部分数值类型的属性都可以参与过渡， 如宽度、高度、内外边距、背景颜色等。需要注意的是
                    ，某些属性，例如display，通常不支持过渡，因为它们的改变不是平滑的。如果想要设置没有任何属性会发生过渡
                    ，把想要过渡的属性设置为none即可。
                    【说明】想要其中多个属性都过渡，有两种方式：
                        方式一：在几组属性值后面加个逗号隔开即可；（如果不同属性的动画时间、运动方式和延迟有差异更推荐这种写法）
                        方式二：想要过渡的属性写一个all就可以（如果不同属性的动画时间、运动方式和延迟无差异更推荐这种写法）
                (2) 花费时间：  单位是秒，必须写单位。比如1s
                (3) 运动曲线：  默认是ease，规定先缓慢地开始，然后加速，然后缓慢地结束（可以省略）
                        属性值              描述
                        linear             匀速
                        ease               先加速后减速（默认）
                        ease-in            缓慢开始，然后加速
                        ease-out           缓慢结束
                        ease-in-out        先加速后减速
                (4)何时开始：  单位是秒，必须写单位，用来设置延迟触发时间，默认是0s（可以省略）
                    【说明】这个延迟时间不仅针对鼠标放上去的时候，也作用于鼠标离开的时候
            2、过渡动画是从一个状态渐渐过渡到另一个状态。可以让我们页面更好看，更动感十足。尽管IE9以下浏览器不兼容，但并不会
                影响页面布局。
            3、通常和:hover搭配使用。但是，transition属性是给元素加而不是E:hover。
        */
        .transition {
            overflow: hidden;
            width: 300px;
            height: 30px;
            margin: 0 auto;
            padding: 2px;
            border: 2px solid red;
            border-radius: 19px;
        }
        .transition_in {
            width: 50%;
            height: 100%;
            background: red;
            border-radius: 15px;
            /* 上下写的方式不生效，存在样式冲突
            transition: width 2s;
            transition: height 2s
             */
            transition: width 2s;
        }
        .transition:hover .transition_in {
            width: 100%;
        }   
    </style>
</head>
<body>
    <h1>CSS也是一种标记语言。主要用于设置HTML的文本内容（字体、大小、对齐方式等）、图片的外形（宽度、边框样式、边距等）以及版面的布局和外观显示样式</h1>
    <p>选择器的作用：根据不同的需求把不同的标签选出来就是选择器的作用。简单来说，就是选标签用的。</p>
    <div class="color star-sing">类选择器，结构使用class属性，变紫色</div>
    <div id="color">id选择器，结构使用id属性，只能被调用一次，别人切勿使用！</div>
    <p id="color">id选择器，结构使用id属性，只能被调用一次！CSS的id选择器可以应用到多个具有相同id的元素上，样式会生效。<br />但是，在JavaScript中，使用document.getElementById()之类的函数只能获取到第一个匹配的元素。出于规范性和代码的可维护性，不建议在HTML中出现重复的id值</p>
    <p>行高可以看我是怎么样的。如果段落换行后的行高是怎样的。xxxxxxxxxxxxxxxusdahfkashflkadjsflsadjfl;ajldsfjal;dfjlasdjflasjfsdal;fjasl;fjsadlfjasl;jfas;fjads;lfjasldsafjalsjfasljfladsjfasklfjsaldjfalfjalsfjlasjflasjdfla;sdjflasjdfla;sjfla;sjflasd;lfljdsalfjasj;</p>
    <div class="font"><span>字体样式：数字设置加粗，斜体</span></div>
    <div><label for="demo">:focus伪类选择器示范</label><input type="text" name="demo" id="demo"></div>
    <div class="block">块元素转化成行内元素，设置宽高无效</div>
    <span class="inline-block">行内元素转化成行内块元素1</span>
    <span class="inline-block">行内元素转化成行内块元素3</span>
    <a href="#">即使body设置了颜色，根据优先级权重，继承的权重为0，浏览器会自动给&lt;a&gt添加样式</a>
    <div class="f-margin">
        <div>嵌套块元素垂直外边距塌陷</div>
    </div>
    <div class="absolute">
        <div>
            绝对定位有祖先元素
        </div>
    </div>
    <div style="margin:40px; text-align: center; background:#e5e5e5">
        <a href="行内下伸空间与vertical-align的关系演示.html">行内下伸空间与vertical-align的关系动画演示</a><br>
    </div>
    <h4 style="text-align: center;">
        土豆网视频播放遮罩层的显示与隐藏（父元素悬停控制）<br>
        方案有：（1）父元素悬停控制；（2）利用opacity代替visibility或display，可以接收鼠标事件
    </h4>
    <div class="potato">
        <div class="mask"></div>
        <img src="images/tudou.jpg">
    </div>
    <h4>精灵图的使用</h4>
    <div class="sprites"></div>
    <span>字体图标：</span><span class="icon"></span>
    <h4>CSS三角</h4>
    <div class="triangle"></div>
    <div class="layout">
        <h1 style="background: pink;">常见布局技巧</h1>
        <h3 style="background: #e5e5e5; margin-bottom: 5px;">margin负值的巧妙运用</h3>
        <ul class="clearfix">
            <li>1</li>
            <li>2</li>
            <li>3</li>
            <li>4</li>
            <li>5</li>
        </ul>
        <h3 style="background: #e5e5e5; margin: 5px;">文字围绕浮动元素</h3>
        <div class="text-flow">
            <div></div>
            <span>我不需要盒子装，浮动的产生本身就是为了实现文字环绕的效果。浮动虽然会脱离文档流，但是它不会压住标准流的文字</span>
        </div>
        <h3 style="background: #e5e5e5; margin: 5px;">CSS三角实现梯形价格对比</h3>
        <div class="miaosha">
            <span class="trapezium">
                <i></i>
                ¥1899
            </span>
            <span>¥5570</span>
        </div>
    </div>
    <h4 style="text-align: center;margin-top:40px;border-top: 3px solid #e5e5e5;">CSS3新增过渡效果（进度条演示）</h4>
    <div class="transition">
        <div class="transition_in"></div>
    </div>
    
</body>
</html> 